# Code Generation Guide for NgGoRPC

NgGoRPC uses **standard Protocol Buffer tooling** without requiring custom code generators. This document explains how to generate client and server code from your `.proto` files.

## Philosophy

Unlike some RPC frameworks that require custom plugins, NgGoRPC leverages:
- **Backend**: Standard `protoc-gen-go` and `protoc-gen-go-grpc` (official Google plugins)
- **Frontend**: Standard `ts-proto` with `outputServices=generic-definitions` option

This approach ensures compatibility with the broader protobuf ecosystem and reduces maintenance burden.

---

## Prerequisites

### For Go Backend

Install the official Protocol Buffer plugins:

```bash
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
```

Verify installation:

```bash
protoc-gen-go --version
protoc-gen-go-grpc --version
```

### For TypeScript Frontend

Install `ts-proto` in your Angular project:

```bash
npm install --save-dev ts-proto
```

Or if using the provided workspace:

```bash
cd frontend
npm install
```

---

## Backend: Generating Go Code

### Step 1: Define Your Service

Create or edit `.proto` files in the `proto/` directory:

```protobuf
syntax = "proto3";

package myapp;

option go_package = "github.com/yourorg/yourapp/generated";

service MyService {
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  rpc StreamEvents(StreamEventsRequest) returns (stream Event);
}

message GetUserRequest {
  string user_id = 1;
}

message GetUserResponse {
  string name = 1;
  string email = 2;
}

message StreamEventsRequest {
  string topic = 1;
}

message Event {
  string id = 1;
  string payload = 2;
  int64 timestamp = 3;
}
```

### Step 2: Run protoc

From your Go module directory:

```bash
protoc \
  --go_out=./generated \
  --go_opt=paths=source_relative \
  --go-grpc_out=./generated \
  --go-grpc_opt=paths=source_relative \
  --proto_path=../proto \
  ../proto/*.proto
```

Or use the provided script:

```bash
cd wsgrpc/scripts
bash protoc.sh
```

### Step 3: Implement the Service

The generated code includes:
- `*_pb.go`: Message types (e.g., `GetUserRequest`, `GetUserResponse`)
- `*_grpc.pb.go`: Service interface (e.g., `MyServiceServer`) and registration function (e.g., `RegisterMyServiceServer`)

Implement the interface:

```go
package main

import (
    "context"
    "fmt"
    "time"
    
    pb "github.com/yourorg/yourapp/generated" // Replace with your actual import path
)

type myServiceImpl struct {
    pb.UnimplementedMyServiceServer // Embedded to satisfy interface
}

func (s *myServiceImpl) GetUser(ctx context.Context, req *pb.GetUserRequest) (*pb.GetUserResponse, error) {
    return &pb.GetUserResponse{
        Name:  "John Doe",  // Field names match proto definition (camelCase becomes PascalCase in Go)
        Email: "john@example.com",
    }, nil
}

func (s *myServiceImpl) StreamEvents(req *pb.StreamEventsRequest, stream pb.MyService_StreamEventsServer) error {
    for i := 0; i < 10; i++ {
        if err := stream.Send(&pb.Event{
            Id:        fmt.Sprintf("evt-%d", i),  // Proto field names become PascalCase
            Payload:   "data",
            Timestamp: time.Now().Unix(),
        }); err != nil {
            return err
        }
        time.Sleep(100 * time.Millisecond)
    }
    return nil
}
```

### Step 4: Register with NgGoRPC Server

```go
package main

import (
    "log"
    
    "github.com/helios57/NgGoRPC/wsgrpc"
    pb "github.com/yourorg/yourapp/generated"
)

func main() {
    server := wsgrpc.NewServer(wsgrpc.ServerOption{
        InsecureSkipVerify: true, // Dev only
    })

    // Register your service implementation
    svc := &myServiceImpl{}
    pb.RegisterMyServiceServer(server, svc)

    // Start server
    if err := server.ListenAndServe(":8080"); err != nil {
        log.Fatal(err)
    }
}
```

**Key Point**: `RegisterMyServiceServer` is generated by `protoc-gen-go-grpc` and accepts any type implementing `grpc.ServiceRegistrar` (which `wsgrpc.Server` does).

---

## Frontend: Generating TypeScript Code

### Step 1: Configure ts-proto

In your Angular project's `package.json`, add a script:

```json
{
  "scripts": {
    "proto:generate": "protoc --plugin=protoc-gen-ts_proto=./node_modules/.bin/protoc-gen-ts_proto --ts_proto_out=./src/app/generated --ts_proto_opt=outputServices=generic-definitions,useExactTypes=false --proto_path=../proto ../proto/*.proto"
  }
}
```

**Important Options**:
- `outputServices=generic-definitions`: Generates service definitions as plain TypeScript objects (compatible with NgGoRPC's `ServiceDefinition` interface)
- `useExactTypes=false`: Allows `Partial<T>` for message creation (better DX)

### Step 2: Run Code Generation

```bash
npm run proto:generate
```

This creates files in `src/app/generated/`:
- `myservice.ts`: Message types and service definition

### Step 3: Use in Angular Components

```typescript
import { Component, inject } from '@angular/core';
import { NgGoRpcClient } from '@nggorpc/client';
import { MyServiceDefinition } from './generated/myservice';

@Component({
  selector: 'app-user',
  template: `
    <div *ngIf="user$ | async as user">
      <h1>{{ user.name }}</h1>
      <p>{{ user.email }}</p>
    </div>
  `
})
export class UserComponent {
  private client = inject(NgGoRpcClient);
  private transport = this.client.createTransport();

  user$ = this.transport.request(
    MyServiceDefinition,
    MyServiceDefinition.methods.getUser,
    { userId: '123' }
  );
}
```

### Step 4: Streaming Example

```typescript
@Component({
  selector: 'app-events',
  template: `<div *ngFor="let event of events">{{ event.payload }}</div>`
})
export class EventsComponent implements OnInit {
  private client = inject(NgGoRpcClient);
  private transport = this.client.createTransport();
  events: Event[] = [];

  ngOnInit() {
    this.transport.request(
      MyServiceDefinition,
      MyServiceDefinition.methods.streamEvents,
      { topic: 'news' }
    ).subscribe({
      next: (event) => {
        this.events.push(event);
      },
      error: (err) => console.error('Stream error:', err),
      complete: () => console.log('Stream complete')
    });
  }
}
```

---

## Advanced: Workspace Setup

For monorepos with both frontend and backend:

### Directory Structure

```
my-project/
├── proto/              # Shared .proto files
│   └── myservice.proto
├── backend/            # Go service
│   ├── go.mod
│   ├── main.go
│   └── generated/      # Generated Go code
└── frontend/           # Angular app
    ├── package.json
    └── src/
        └── app/
            └── generated/  # Generated TS code
```

### Automation

Create a root-level `Makefile`:

```makefile
.PHONY: generate-all generate-go generate-ts

generate-all: generate-go generate-ts

generate-go:
	cd backend && protoc \
		--go_out=./generated \
		--go_opt=paths=source_relative \
		--go-grpc_out=./generated \
		--go-grpc_opt=paths=source_relative \
		--proto_path=../proto \
		../proto/*.proto

generate-ts:
	cd frontend && npm run proto:generate
```

Run:

```bash
make generate-all
```

---

## Why No Custom Generator?

You might wonder why NgGoRPC doesn't provide a `protoc-gen-nggorpc` plugin. Here's why:

1. **Standard Compatibility**: Using official plugins ensures compatibility with existing gRPC tooling, IDEs, and linters.

2. **Maintenance Burden**: Custom generators require ongoing maintenance for every protobuf version and language feature update.

3. **Service Registration**: The key integration point is `RegisterMyServiceServer`, which is already generated by `protoc-gen-go-grpc` and works seamlessly with `wsgrpc.Server`.

4. **Transport Abstraction**: The frontend `WebSocketRpcTransport` implements the `Rpc` interface that `ts-proto` expects, requiring no custom generation.

5. **Flexibility**: Users can customize `ts-proto` options (e.g., `useOptionals`, `oneof=unions`) without waiting for custom generator updates.

**Trade-off**: Users must understand they're using "standard gRPC generation" with a "custom transport layer" rather than a fully integrated custom solution. The README and this guide bridge that knowledge gap.

---

## Troubleshooting

### Issue: `protoc: command not found`

Install Protocol Buffers compiler:

**macOS**:
```bash
brew install protobuf
```

**Linux (Debian/Ubuntu)**:
```bash
sudo apt install protobuf-compiler
```

**Windows**:
Download from https://github.com/protocolbuffers/protobuf/releases

### Issue: `protoc-gen-go: program not found`

Ensure `$GOPATH/bin` (or `$HOME/go/bin`) is in your `PATH`:

```bash
export PATH="$PATH:$(go env GOPATH)/bin"
```

Add to `.bashrc` or `.zshrc` for persistence.

### Issue: TypeScript Errors - `Property 'methods' does not exist`

Verify `ts-proto` options include `outputServices=generic-definitions`:

```json
{
  "scripts": {
    "proto:generate": "protoc ... --ts_proto_opt=outputServices=generic-definitions,..."
  }
}
```

### Issue: Generated Go Code Import Errors

Ensure `go_package` option in `.proto` matches your module structure:

```protobuf
option go_package = "github.com/yourorg/yourapp/generated";
```

Then run:
```bash
go mod tidy
```

---

## See Also

- [README.md](README.md) - Full project documentation
- [PROTOCOL.md](PROTOCOL.md) - NgGoRPC wire protocol specification
- [ts-proto documentation](https://github.com/stephenh/ts-proto) - TypeScript generator options
- [gRPC-Go documentation](https://grpc.io/docs/languages/go/) - Official Go gRPC guide
